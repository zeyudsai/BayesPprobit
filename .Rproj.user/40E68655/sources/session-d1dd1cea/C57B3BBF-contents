#' @title p-Generalized Gaussian Distribution Functions
#' @description Density, distribution, quantile and random generation functions
#' for the p-generalized Gaussian distribution according to the paper definition
#' @name pggd
NULL

#' @rdname pggd
#' @param p Shape parameter
#' @return Scale parameter value
#' @export
p_scale <- function(p) {
  if (!is.numeric(p) || length(p) != 1 || p <= 0) {
    stop("`p` must be a single positive numeric value.")
  }
  p^(1/p)
}

#' @rdname pggd
#' @param x,q Numeric vector of quantiles
#' @param mu Location parameter
#' @param p Shape parameter
#' @param log Logical; if TRUE, return log density
#' @export
dgnorm <- function(x, mu = 0, p = 2, log = FALSE) {
  # Validate inputs
  if (!is.numeric(p) || any(p <= 0)) stop("p must be positive")
  
  # Get scale parameter
  alpha <- p_scale(p)
  
  # Compute coefficient
  coef <- p^(1 - 1/p)/(2 * gamma(1/p))
  
  # Compute exponent
  exponent <- -(abs(x - mu)^p)/p
  
  if (log) {
    return(log(coef) + exponent)
  } else {
    return(coef * exp(exponent))
  }
}

#' @rdname pggd
#' @param lower.tail Logical; if TRUE, probabilities are P[X â‰¤ x]
#' @export
pgnorm <- function(q, mu = 0, p = 2, lower.tail = TRUE) {
  # For vectors, apply elementwise
  if (length(q) > 1) {
    return(sapply(q, function(x) {
      pgnorm(x, mu, p, lower.tail)
    }))
  }
  
  # Integrate density function
  result <- stats::integrate(
    dgnorm,
    lower = -Inf,
    upper = q,
    mu = mu,
    p = p,
    rel.tol = .Machine$double.eps^0.5
  )$value
  
  if (!lower.tail) result <- 1 - result
  return(result)
}

#' @rdname pggd
#' @param p_vals Numeric vector of probabilities
#' @export
qgnorm <- function(p_vals, mu = 0, p = 2) {
  # For vectors, apply elementwise
  if (length(p_vals) > 1) {
    return(sapply(p_vals, function(x) {
      qgnorm(x, mu, p)
    }))
  }
  
  # Validate probability
  if (p_vals < 0 || p_vals > 1) 
    stop("p_vals must be between 0 and 1")
  
  # Get scale parameter
  alpha <- p_scale(p)
  
  # Find root of CDF - p
  stats::uniroot(
    function(x) pgnorm(x, mu, p) - p_vals,
    interval = c(mu - 10*alpha, mu + 10*alpha),
    tol = .Machine$double.eps^0.5
  )$root
}

#' @rdname pggd
#' @param n Number of observations
#' @export
rgnorm <- function(n, mu = 0, p = 2) {
  # Generate uniform random numbers
  u <- stats::runif(n)
  
  # Transform to p-GGD using inverse CDF
  qgnorm(u, mu, p)
}

#' @rdname pggd
#' @param n Number of observations
#' @param mu Location parameter
#' @param p Shape parameter
#' @param lower Lower truncation point
#' @param upper Upper truncation point
#' @keywords internal
rtrunc_pggd <- function(n, mu = 0, p = 2, lower = -Inf, upper = Inf) {
  # Get CDF at truncation points
  F_lower <- if(is.finite(lower)) pgnorm(lower, mu, p) else 0
  F_upper <- if(is.finite(upper)) pgnorm(upper, mu, p) else 1
  
  # Generate uniform between F_lower and F_upper
  u <- stats::runif(n, F_lower, F_upper)
  
  # Transform to truncated p-GGD
  qgnorm(u, mu, p)
}